extern crate libpulse_binding as pulse;

use std::sync::atomic;
use std::rc::Rc;
use std::cell::RefCell;
use std::ops::Deref;
use pulse::mainloop::standard::Mainloop;
use pulse::context::{Context, FlagSet as ContextFlagSet};
use pulse::context::subscribe::Facility;
use pulse::stream::{Stream, FlagSet as StreamFlagSet};
use pulse::sample::{Spec, Format};
use pulse::proplist::Proplist;
use pulse::mainloop::standard::IterateResult;
use pulse::def::Retval;

fn main() {
    let spec = Spec {
        format: Format::S16NE,
        channels: 2,
        rate: 44100,
    };
    assert!(spec.is_valid());

    let mut proplist = Proplist::new().unwrap();
    proplist.set_str(pulse::proplist::properties::APPLICATION_NAME, "FooApp")
        .unwrap();

    let mut mainloop = Rc::new(RefCell::new(Mainloop::new()
        .expect("Failed to create mainloop")));

    let mut context = Rc::new(RefCell::new(Context::new_with_proplist(
        mainloop.borrow().deref(),
        "FooAppContext",
        &proplist
        ).expect("Failed to create new context")));

    context.borrow_mut().connect(None, ContextFlagSet::NOFLAGS, None)
        .expect("Failed to connect context");

    // Wait for context to be ready
    loop {
        match mainloop.borrow_mut().iterate(false) {
            IterateResult::Quit(_) |
            IterateResult::Err(_) => {
                eprintln!("Iterate state was not success, quitting...");
                return;
            },
            IterateResult::Success(_) => {},
        }
        match context.borrow().get_state() {
            pulse::context::State::Ready => {
                println!("conext is ready!");
                break;
            },
            pulse::context::State::Failed |
            pulse::context::State::Terminated => {
                eprintln!("Context state failed/terminated, quitting...");
                return;
            },
            _ => {},
        }
    }

    let context_copy = context.clone();
    context.borrow_mut().set_subscribe_callback(Some(Box::new(
        move |facility,operation,index| {
            let facility = facility.unwrap();
            let operation = operation.unwrap();
            match facility {
                Facility::Sink => {
                    context_copy.borrow_mut().introspect().get_server_info(|s|
                        {
                            println!("{:?}", s)
                        });
                }
                Facility::Source => {}
                Facility::SinkInput => {}
                Facility::SourceOutput => {}
                Facility::Module => {}
                Facility::Client => {}
                Facility::SampleCache => {}
                Facility::Server => {}
                Facility::Card => {}
            }

        println!("Subscribe callback: {:?}, {:?}, {}", facility, operation, index);
    })));
    context.borrow_mut().subscribe(pulse::context::subscribe::InterestMaskSet::all(), |done| {
        println!("done: {}", done);
    });
    context.borrow_mut().set_state_callback(Some(Box::new(|| {
        println!("Set state callback");
    })));

    // Run the main loop
    mainloop.borrow_mut().run().unwrap();

    // Clean shutdown
    mainloop.borrow_mut().quit(Retval(0)); // uncertain whether this is necessary
}
